<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Build a Rasterizer With Webgpu 01 | My New Hugo Site</title>
<meta name="keywords" content="">
<meta name="description" content="Now since WebGPU is offcially rolled out in Chrome browser, let&rsquo;s try it out by building a rasterizer using this new API.
Basic Setup First, we need to check everything is ready for WebGPU. We can do this by checking if the navigator.gpu is available.
if (!navigator.gpu) { console.error(&#39;WebGPU is not supported&#39;); return; } If you have error in your console, that means you need to download the latest version of Chrome.">
<meta name="author" content="">
<link rel="canonical" href="http://example.org/posts/build-a-rasterizer-with-webgpu/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.bf5f9f73cf17311d52cedbcda82c922e91b2f566d88a85ad9f5b5a08b586bd5f.css" integrity="sha256-v1&#43;fc88XMR1SztvNqCySLpGy9WbYioWtn1taCLWGvV8=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.acb54fd32bbc1982428b8850317e45d076b95012730a5936667e6bc21777692a.js" integrity="sha256-rLVP0yu8GYJCi4hQMX5F0Ha5UBJzClk2Zn5rwhd3aSo="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="http://example.org/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="http://example.org/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="http://example.org/favicon-32x32.png">
<link rel="apple-touch-icon" href="http://example.org/apple-touch-icon.png">
<link rel="mask-icon" href="http://example.org/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:title" content="Build a Rasterizer With Webgpu 01" />
<meta property="og:description" content="Now since WebGPU is offcially rolled out in Chrome browser, let&rsquo;s try it out by building a rasterizer using this new API.
Basic Setup First, we need to check everything is ready for WebGPU. We can do this by checking if the navigator.gpu is available.
if (!navigator.gpu) { console.error(&#39;WebGPU is not supported&#39;); return; } If you have error in your console, that means you need to download the latest version of Chrome." />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://example.org/posts/build-a-rasterizer-with-webgpu/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-05-24T08:45:31+08:00" />
<meta property="article:modified_time" content="2023-05-24T08:45:31+08:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Build a Rasterizer With Webgpu 01"/>
<meta name="twitter:description" content="Now since WebGPU is offcially rolled out in Chrome browser, let&rsquo;s try it out by building a rasterizer using this new API.
Basic Setup First, we need to check everything is ready for WebGPU. We can do this by checking if the navigator.gpu is available.
if (!navigator.gpu) { console.error(&#39;WebGPU is not supported&#39;); return; } If you have error in your console, that means you need to download the latest version of Chrome."/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "http://example.org/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Build a Rasterizer With Webgpu 01",
      "item": "http://example.org/posts/build-a-rasterizer-with-webgpu/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Build a Rasterizer With Webgpu 01",
  "name": "Build a Rasterizer With Webgpu 01",
  "description": "Now since WebGPU is offcially rolled out in Chrome browser, let\u0026rsquo;s try it out by building a rasterizer using this new API.\nBasic Setup First, we need to check everything is ready for WebGPU. We can do this by checking if the navigator.gpu is available.\nif (!navigator.gpu) { console.error(\u0026#39;WebGPU is not supported\u0026#39;); return; } If you have error in your console, that means you need to download the latest version of Chrome.",
  "keywords": [
    
  ],
  "articleBody": "Now since WebGPU is offcially rolled out in Chrome browser, let’s try it out by building a rasterizer using this new API.\nBasic Setup First, we need to check everything is ready for WebGPU. We can do this by checking if the navigator.gpu is available.\nif (!navigator.gpu) { console.error('WebGPU is not supported'); return; } If you have error in your console, that means you need to download the latest version of Chrome. If you are on Linux, As of now, you have to download the dev version of Chrome and enable the WebGPU flag, you probably also need to enable the Vulkan flag and install the Vulkan SDK.\nNext, we need to create a GPU device.\n// first we need to request an adapter // an adapter is a physical device that can be used to render graphics, namely a GPU const adapter = await navigator.gpu.requestAdapter(); // then we need to request a device // think of a device as a logical handle to a physical device const device = await adapter.requestDevice(); Now we have a device which we can use to create other WebGPU objects.\nAs we are just starting out, we will not bother ourselves with the canvas API, instead we will get a basic compute shader running and send data to it.\nCompute Shader A compute shader is a program that runs on the GPU. It is used to perform general purpose computation on the GPU. For people we are not familiar with the graphics pipeline, it is a good place to start. As you are free from the vertex and fragment shader complexity, instead you can treat the GPU as a parallel processor, and you feed it with data and get the result back.\nCreate a Compute Pipeline In order to use compute shader, we need to create a compute pipeline. A compute pipeline is a collection of GPU state that controls how the compute shader is executed.\nOther than the compute shader, you also need to specify what data you want to pass to the shader. This is done by creating a bind group layout and bind group.\nYou can think of a bind group layout as a blueprint of the data you want to pass to the shader. It specifies the type of the data and the binding index. The bind group is the actual data you want to pass to the shader. It is created based on the bind group layout.\nthe shader content :\nstruct ColorBuffer{ values: array }; // this is the final output buffer from our shader. @group(0) @binding(0) var color_buffer: ColorBuffer; // we are using workgroup_size(1) here // this is stupid, but it is easy to see how the global_invocation_id works. @compute @workgroup_size(1) fn main(@builtin(global_invocation_id) global_id: vec3) { // multiply by 3 because we have 3 channels let index = global_id.x * 3; color_buffer.values[index] = index; color_buffer.values[index + 1] = index + 1; color_buffer.values[index + 2] = index + 2; } we create the compute pipeline like this:\nconst width = 100; const height = 100; const channels = 3; // each pixel has 3 channels, r, g, b and each channel is a 32 bit unsigned integer // we are wasting a lot of space here, but it saves // us from doing some bit shifting in the shader. const colorBufferSize = width * height * Uint32Array.BYTES_PER_ELEMENT * channels; const colorBuffer = device.createBuffer({ size: colorBufferSize, // we need to specify the usage of the buffer // here we are using the buffer as a storage buffer and a copy source // we specify the copy source usage because we want to copy the data from the buffer to the CPU which we will do later. usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC }); // create bind group layout const bindGroupLayout = device.createBindGroupLayout({ entries: [ { binding: 0, visibility: GPUShaderStage.COMPUTE, buffer: { type: \"storage\" } }, ] }); // create bind group const bindGroup = device.createBindGroup({ layout: bindGroupLayout, entries: [ { binding: 0, resource: { buffer: colorBuffer } }, ] }); // create shader module const computeShaderModule = device.createShaderModule({ code: computeShaderCode }); // create compute pipeline const computePipeline = device.createComputePipeline({ layout: device.createPipelineLayout({ bindGroupLayouts: [bindGroupLayout] }), compute: { module: computeShaderModule, entryPoint: \"main\" } }); With those prepartions in place we are finally ready to do some computation on the GPU.\nRun the Compute Shader const commandEncoder = device.createCommandEncoder(); const computePass = commandEncoder.beginComputePass(); computePass.setPipeline(computePipeline); computePass.setBindGroup(0, bindGroup); computePass.dispatchWorkgroups(width * height); computePass.end(); // submit the command encoder to the GPU device.queue.submit([commandEncoder.finish()]); Copy the Data Back to CPU By now the gpu has finished the computation for us, in this case, the computation is simple, it just set the buffer value to the buffer index.\nNow we need to copy the data back to the CPU so we can see the result.\n// create a staging buffer const stagingBuffer = device.createBuffer({ size: colorBufferSize, // here we use the buffer as a copy destination and a map read // map read means we can map the buffer to the CPU usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ }); // copy the data from the color buffer to the staging buffer commandEncoder.copyBufferToBuffer(colorBuffer, 0, stagingBuffer, 0, colorBufferSize); // submit the command encoder to the GPU device.queue.submit([commandEncoder.finish()]); // map the staging buffer to the CPU await stagingBuffer.mapAsync(GPUMapMode.READ); // get the array buffer from the staging buffer const arrayBuffer = stagingBuffer.getMappedRange(); const data = new Uint32Array(arrayBuffer.slice(0)); arrayBuffer.unmap(); // log the data console.log(data); In console, you will see an array of number from 0 to 9999, which is the index of the buffer.\nGraphics Pipeline So many lines of code to just get a bunch of useless numbers, that’s not very interesting. Let’s try to do something more interesting, like rendering our previous generated data to the screen.\nCreate a Graphics Pipeline In order to render something to the screen, we need to create a graphics pipeline. A graphics pipeline is a collection of GPU state that controls how the vertex and fragment shader is executed.\nA thorough explanation of the graphics pipeline is beyond the scope of this article, please consult other resources if you are interested.\nIn our case, we are not going to do a proper vertex transformation and fragment shading because we are not providing any vertex data, we are just going to render a color buffer (previously generated) to the screen.\nlet’s set up our vertex and fragment shader first\n// this is the data we are going to pass to the shader // it has the same structure as the data we generated in the compute shader struct ColorData { values: array }; struct Uniform { screenWidth: f32, screenHeight: f32 }; @group(0) @binding(0) var uniforms: Uniform; @group(0) @binding(1) var color_data: ColorData; struct VertexOutput { @builtin(position) position: vec4 }; @vertex fn vs_main(@builtin(vertex_index) vertexIndex : u32) -\u003e VertexOutput { var pos = array",
  "wordCount" : "2073",
  "inLanguage": "en",
  "datePublished": "2023-05-24T08:45:31+08:00",
  "dateModified": "2023-05-24T08:45:31+08:00",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "http://example.org/posts/build-a-rasterizer-with-webgpu/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "My New Hugo Site",
    "logo": {
      "@type": "ImageObject",
      "url": "http://example.org/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="http://example.org/" accesskey="h" title="My New Hugo Site (Alt + H)">My New Hugo Site</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title">
      Build a Rasterizer With Webgpu 01
    </h1>
    <div class="post-meta"><span title='2023-05-24 08:45:31 +0800 CST'>May 24, 2023</span>

</div>
  </header> 
  <div class="post-content"><p>Now since WebGPU is offcially rolled out in Chrome browser, let&rsquo;s try it out by building a rasterizer using this new API.</p>
<h2 id="basic-setup">Basic Setup<a hidden class="anchor" aria-hidden="true" href="#basic-setup">#</a></h2>
<p>First, we need to check everything is ready for WebGPU. We can do this by checking if the <code>navigator.gpu</code> is available.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span><span style="color:#a6e22e">navigator</span>.<span style="color:#a6e22e">gpu</span>) {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">error</span>(<span style="color:#e6db74">&#39;WebGPU is not supported&#39;</span>);
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>If you have error in your console, that means you need to download the latest version of Chrome. If you are on Linux, As of now, you have to download the dev version of Chrome and enable the WebGPU flag, you probably also need to enable the Vulkan flag and install the Vulkan SDK.</p>
<p>Next, we need to create a GPU device.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#75715e">// first we need to request an adapter
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// an adapter is a physical device that can be used to render graphics, namely a GPU
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">adapter</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">await</span> <span style="color:#a6e22e">navigator</span>.<span style="color:#a6e22e">gpu</span>.<span style="color:#a6e22e">requestAdapter</span>();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// then we need to request a device
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// think of a device as a logical handle to a physical device
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">device</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">await</span> <span style="color:#a6e22e">adapter</span>.<span style="color:#a6e22e">requestDevice</span>();
</span></span></code></pre></div><p>Now we have a device which we can use to create other WebGPU objects.</p>
<p>As we are just starting out,  we will not bother ourselves with the canvas API, instead we will get a basic compute shader running and send data to it.</p>
<h2 id="compute-shader">Compute Shader<a hidden class="anchor" aria-hidden="true" href="#compute-shader">#</a></h2>
<p>A compute shader is a program that runs on the GPU. It is used to perform general purpose computation on the GPU. For people we are not familiar with the graphics pipeline, it is a good place to start. As you are free from the vertex and fragment shader complexity, instead you can treat the GPU as a parallel processor, and you feed it with data and get the result back.</p>
<h3 id="create-a-compute-pipeline">Create a Compute Pipeline<a hidden class="anchor" aria-hidden="true" href="#create-a-compute-pipeline">#</a></h3>
<p>In order to use compute shader, we need to create a compute pipeline. A compute pipeline is a collection of GPU state that controls how the compute shader is executed.</p>
<p>Other than the compute shader, you also need to specify what data you want to pass to the shader. This is done by creating a bind group layout and bind group.</p>
<p>You can think of a bind group layout as a blueprint of the data you want to pass to the shader. It specifies the type of the data and the binding index. The bind group is the actual data you want to pass to the shader. It is created based on the bind group layout.</p>
<p>the shader content :</p>
<pre tabindex="0"><code class="language-wgsl" data-lang="wgsl">  struct ColorBuffer{
    values: array&lt;u32&gt;
  };

  // this is the final output buffer from our shader.
  @group(0) @binding(0) var&lt;storage, read_write&gt; color_buffer: ColorBuffer;

  // we are using workgroup_size(1) here 
  // this is stupid, but it is easy to see how the global_invocation_id works.
  @compute @workgroup_size(1)
  fn main(@builtin(global_invocation_id) global_id: vec3&lt;u32&gt;) {
    // multiply by 3 because we have 3 channels
    let index = global_id.x * 3;
    color_buffer.values[index] = index;
    color_buffer.values[index + 1] = index + 1;
    color_buffer.values[index + 2] = index + 2;
  }
</code></pre><p>we create the compute pipeline like this:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span>  <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">width</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">100</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">height</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">100</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">channels</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">3</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// each pixel has 3 channels, r, g, b and each channel is a 32 bit unsigned integer
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// we are wasting a lot of space here, but it saves
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// us from doing some bit shifting in the shader.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">colorBufferSize</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">width</span> <span style="color:#f92672">*</span> <span style="color:#a6e22e">height</span> <span style="color:#f92672">*</span> <span style="color:#a6e22e">Uint32Array</span>.<span style="color:#a6e22e">BYTES_PER_ELEMENT</span> <span style="color:#f92672">*</span> <span style="color:#a6e22e">channels</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">colorBuffer</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">device</span>.<span style="color:#a6e22e">createBuffer</span>({
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">size</span>: <span style="color:#66d9ef">colorBufferSize</span>,
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// we need to specify the usage of the buffer
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// here we are using the buffer as a storage buffer and a copy source
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// we specify the copy source usage because we want to copy the data from the buffer to the CPU which we will do later.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">usage</span>: <span style="color:#66d9ef">GPUBufferUsage.STORAGE</span> <span style="color:#f92672">|</span> <span style="color:#a6e22e">GPUBufferUsage</span>.<span style="color:#a6e22e">COPY_SRC</span>
</span></span><span style="display:flex;"><span>  });
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// create bind group layout
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">bindGroupLayout</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">device</span>.<span style="color:#a6e22e">createBindGroupLayout</span>({
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">entries</span><span style="color:#f92672">:</span> [
</span></span><span style="display:flex;"><span>      {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">binding</span>: <span style="color:#66d9ef">0</span>,
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">visibility</span>: <span style="color:#66d9ef">GPUShaderStage.COMPUTE</span>,
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">buffer</span><span style="color:#f92672">:</span> {
</span></span><span style="display:flex;"><span>          <span style="color:#66d9ef">type</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;storage&#34;</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>      },
</span></span><span style="display:flex;"><span>    ]
</span></span><span style="display:flex;"><span>  });
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// create bind group
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">bindGroup</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">device</span>.<span style="color:#a6e22e">createBindGroup</span>({
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">layout</span>: <span style="color:#66d9ef">bindGroupLayout</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">entries</span><span style="color:#f92672">:</span> [
</span></span><span style="display:flex;"><span>      {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">binding</span>: <span style="color:#66d9ef">0</span>,
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">resource</span><span style="color:#f92672">:</span> {
</span></span><span style="display:flex;"><span>          <span style="color:#a6e22e">buffer</span>: <span style="color:#66d9ef">colorBuffer</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>      },
</span></span><span style="display:flex;"><span>    ]
</span></span><span style="display:flex;"><span>  });
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// create shader module
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">computeShaderModule</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">device</span>.<span style="color:#a6e22e">createShaderModule</span>({
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">code</span>: <span style="color:#66d9ef">computeShaderCode</span>
</span></span><span style="display:flex;"><span>  });
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// create compute pipeline
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">computePipeline</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">device</span>.<span style="color:#a6e22e">createComputePipeline</span>({
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">layout</span>: <span style="color:#66d9ef">device.createPipelineLayout</span>({ <span style="color:#a6e22e">bindGroupLayouts</span><span style="color:#f92672">:</span> [<span style="color:#a6e22e">bindGroupLayout</span>] }),
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">compute</span><span style="color:#f92672">:</span> { <span style="color:#a6e22e">module</span>: <span style="color:#66d9ef">computeShaderModule</span>, <span style="color:#a6e22e">entryPoint</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;main&#34;</span> }
</span></span><span style="display:flex;"><span>  });
</span></span></code></pre></div><p>With those prepartions in place we are finally ready to do some computation on the GPU.</p>
<h3 id="run-the-compute-shader">Run the Compute Shader<a hidden class="anchor" aria-hidden="true" href="#run-the-compute-shader">#</a></h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span>  <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">commandEncoder</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">device</span>.<span style="color:#a6e22e">createCommandEncoder</span>();
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">computePass</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">commandEncoder</span>.<span style="color:#a6e22e">beginComputePass</span>();
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">computePass</span>.<span style="color:#a6e22e">setPipeline</span>(<span style="color:#a6e22e">computePipeline</span>);
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">computePass</span>.<span style="color:#a6e22e">setBindGroup</span>(<span style="color:#ae81ff">0</span>, <span style="color:#a6e22e">bindGroup</span>);
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">computePass</span>.<span style="color:#a6e22e">dispatchWorkgroups</span>(<span style="color:#a6e22e">width</span> <span style="color:#f92672">*</span> <span style="color:#a6e22e">height</span>);
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">computePass</span>.<span style="color:#a6e22e">end</span>();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// submit the command encoder to the GPU
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#a6e22e">device</span>.<span style="color:#a6e22e">queue</span>.<span style="color:#a6e22e">submit</span>([<span style="color:#a6e22e">commandEncoder</span>.<span style="color:#a6e22e">finish</span>()]);
</span></span></code></pre></div><h3 id="copy-the-data-back-to-cpu">Copy the Data Back to CPU<a hidden class="anchor" aria-hidden="true" href="#copy-the-data-back-to-cpu">#</a></h3>
<p>By now the gpu has finished the computation for us, in this case, the computation is simple, it just set the buffer value to the buffer index.</p>
<p>Now we need to copy the data back to the CPU so we can see the result.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span>  <span style="color:#75715e">// create a staging buffer
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">stagingBuffer</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">device</span>.<span style="color:#a6e22e">createBuffer</span>({
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">size</span>: <span style="color:#66d9ef">colorBufferSize</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// here we use the buffer as a copy destination and a map read
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// map read means we can map the buffer to the CPU
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">usage</span>: <span style="color:#66d9ef">GPUBufferUsage.COPY_DST</span> <span style="color:#f92672">|</span> <span style="color:#a6e22e">GPUBufferUsage</span>.<span style="color:#a6e22e">MAP_READ</span>
</span></span><span style="display:flex;"><span>  });
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// copy the data from the color buffer to the staging buffer
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#a6e22e">commandEncoder</span>.<span style="color:#a6e22e">copyBufferToBuffer</span>(<span style="color:#a6e22e">colorBuffer</span>, <span style="color:#ae81ff">0</span>, <span style="color:#a6e22e">stagingBuffer</span>, <span style="color:#ae81ff">0</span>, <span style="color:#a6e22e">colorBufferSize</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// submit the command encoder to the GPU
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#a6e22e">device</span>.<span style="color:#a6e22e">queue</span>.<span style="color:#a6e22e">submit</span>([<span style="color:#a6e22e">commandEncoder</span>.<span style="color:#a6e22e">finish</span>()]);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// map the staging buffer to the CPU
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">await</span> <span style="color:#a6e22e">stagingBuffer</span>.<span style="color:#a6e22e">mapAsync</span>(<span style="color:#a6e22e">GPUMapMode</span>.<span style="color:#a6e22e">READ</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// get the array buffer from the staging buffer
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">arrayBuffer</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">stagingBuffer</span>.<span style="color:#a6e22e">getMappedRange</span>();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">data</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">Uint32Array</span>(<span style="color:#a6e22e">arrayBuffer</span>.<span style="color:#a6e22e">slice</span>(<span style="color:#ae81ff">0</span>));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">arrayBuffer</span>.<span style="color:#a6e22e">unmap</span>();
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// log the data
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">data</span>);
</span></span></code></pre></div><p>In console, you will see an array of number from 0 to 9999, which is the index of the buffer.</p>
<h2 id="graphics-pipeline">Graphics Pipeline<a hidden class="anchor" aria-hidden="true" href="#graphics-pipeline">#</a></h2>
<p>So many lines of code to just get a bunch of useless numbers, that&rsquo;s not very interesting. Let&rsquo;s try to do something more interesting, like rendering our previous generated data to the screen.</p>
<h3 id="create-a-graphics-pipeline">Create a Graphics Pipeline<a hidden class="anchor" aria-hidden="true" href="#create-a-graphics-pipeline">#</a></h3>
<p>In order to render something to the screen, we need to create a graphics pipeline. A graphics pipeline is a collection of GPU state that controls how the vertex and fragment shader is executed.</p>
<p>A thorough explanation of the graphics pipeline is beyond the scope of this article, please consult other resources if you are interested.</p>
<p>In our case, we are not going to do a proper vertex transformation and fragment shading because we are not providing any vertex data, we are just going to render a color buffer (previously generated) to the screen.</p>
<p>let&rsquo;s set up our vertex and fragment shader first</p>
<pre tabindex="0"><code class="language-wgsl" data-lang="wgsl">// this is the data we are going to pass to the shader
// it has the same structure as the data we generated in the compute shader
struct ColorData {
    values: array&lt;u32&gt;
};

struct Uniform {
    screenWidth: f32,
    screenHeight: f32
};

@group(0) @binding(0) var&lt;uniform&gt; uniforms: Uniform;
@group(0) @binding(1) var&lt;storage&gt; color_data: ColorData;

struct VertexOutput {
    @builtin(position) position: vec4&lt;f32&gt;
};

@vertex
fn vs_main(@builtin(vertex_index) vertexIndex : u32) -&gt; VertexOutput {
    var pos = array&lt;vec2&lt;f32&gt;, 6&gt;(
        vec2&lt;f32&gt;( 1.0,  1.0),
        vec2&lt;f32&gt;( 1.0, -1.0),
        vec2&lt;f32&gt;(-1.0, -1.0),
        vec2&lt;f32&gt;( 1.0,  1.0),
        vec2&lt;f32&gt;(-1.0, -1.0),
        vec2&lt;f32&gt;(-1.0,  1.0)
    );
    var output: VertexOutput;
    output.position = vec4&lt;f32&gt;(pos[vertexIndex], 0.0, 1.0);
    return output;
}


@fragment
fn fs_main(@builtin(position) pos: vec4&lt;f32&gt;) -&gt; @location(0) vec4&lt;f32&gt; {
    let x = floor(pos.x);
    let y = floor(pos.y);
    let index = u32(x + y * uniforms.screenWidth) * 3;

    let combinations = uniforms.screenWidth * uniforms.screenHeight;

    // this is u32
    let r = f32(color_data.values[index + 0]) / pixels;
    let g = f32(color_data.values[index + 1]) / pixels;
    let b = f32(color_data.values[index + 2]) / pixels;

    return vec4&lt;f32&gt;(r, g, b, 1.0);
}
</code></pre><p>the vertex shader and fragment shader is simple, we bind the color buffer to the fragment shader and use the buffer index to get the data value.</p>
<p>the graphics pipeline creation follows the same routine as with the compute pipeline. The only difference is that we need to create a canvas and a canvas context to render the result to the screen.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span>  <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">canvas</span> <span style="color:#f92672">=</span> document.<span style="color:#a6e22e">getElementById</span>(<span style="color:#e6db74">&#34;canvas&#34;</span>) <span style="color:#66d9ef">as</span> <span style="color:#a6e22e">HTMLCanvasElement</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// set the width and height of the canvas to our color buffer size.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#a6e22e">canvas</span>.<span style="color:#a6e22e">width</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">width</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">canvas</span>.<span style="color:#a6e22e">height</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">height</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// create a canvas context
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">context</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">canvas</span>.<span style="color:#a6e22e">getContext</span>(<span style="color:#e6db74">&#34;webgpu&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">format</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;bgra8unorm&#34;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">context</span>.<span style="color:#a6e22e">configure</span>({
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">device</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">format</span>,
</span></span><span style="display:flex;"><span>  });
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">graphicsShader</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">device</span>.<span style="color:#a6e22e">createShaderModule</span>({
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">code</span>: <span style="color:#66d9ef">graphicsShaderSource</span>
</span></span><span style="display:flex;"><span>  });
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">const</span> 
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// other than the color buffer we created before, 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// we binded a uniform buffer to the graphics pipeline
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// the uniform buffer contains the screen width and height
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// we need this to calculate the index of the color buffer
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">graphicsBindGroupLayout</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">device</span>.<span style="color:#a6e22e">createBindGroupLayout</span>({
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">entries</span><span style="color:#f92672">:</span> [
</span></span><span style="display:flex;"><span>      {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">binding</span>: <span style="color:#66d9ef">0</span>,
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">visibility</span>: <span style="color:#66d9ef">GPUShaderStage.FRAGMENT</span>,
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">buffer</span><span style="color:#f92672">:</span> {
</span></span><span style="display:flex;"><span>          <span style="color:#66d9ef">type</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;uniform&#34;</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>      },
</span></span><span style="display:flex;"><span>      {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">binding</span>: <span style="color:#66d9ef">1</span>,<span style="color:#75715e">// the color buffer
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#a6e22e">visibility</span>: <span style="color:#66d9ef">GPUShaderStage.FRAGMENT</span>,
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">buffer</span><span style="color:#f92672">:</span> {
</span></span><span style="display:flex;"><span>          <span style="color:#66d9ef">type</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;read-only-storage&#34;</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>    ]
</span></span><span style="display:flex;"><span>  });
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">graphicsPipeline</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">device</span>.<span style="color:#a6e22e">createRenderPipeline</span>({
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">layout</span>: <span style="color:#66d9ef">device.createPipelineLayout</span>({
</span></span><span style="display:flex;"><span>      <span style="color:#a6e22e">bindGroupLayouts</span><span style="color:#f92672">:</span> [<span style="color:#a6e22e">graphicsBindGroupLayout</span>]
</span></span><span style="display:flex;"><span>    }),
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">vertex</span><span style="color:#f92672">:</span> {
</span></span><span style="display:flex;"><span>      <span style="color:#a6e22e">module</span>: <span style="color:#66d9ef">graphicsShader</span>,
</span></span><span style="display:flex;"><span>      <span style="color:#a6e22e">entryPoint</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;vs_main&#34;</span>,
</span></span><span style="display:flex;"><span>    },
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">fragment</span><span style="color:#f92672">:</span> {
</span></span><span style="display:flex;"><span>      <span style="color:#a6e22e">module</span>: <span style="color:#66d9ef">graphicsShader</span>,
</span></span><span style="display:flex;"><span>      <span style="color:#a6e22e">entryPoint</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;fs_main&#34;</span>,
</span></span><span style="display:flex;"><span>      <span style="color:#a6e22e">targets</span><span style="color:#f92672">:</span> [
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>          <span style="color:#a6e22e">format</span>: <span style="color:#66d9ef">swapChainFormat</span>,
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>      ]
</span></span><span style="display:flex;"><span>    },
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">primitive</span><span style="color:#f92672">:</span> {
</span></span><span style="display:flex;"><span>      <span style="color:#a6e22e">topology</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;triangle-list&#34;</span>,
</span></span><span style="display:flex;"><span>    },
</span></span><span style="display:flex;"><span>  });
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// uniform buffer contains the screen width and height. 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">uniformBufferSize</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">4</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">2</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">uniformBuffer</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">device</span>.<span style="color:#a6e22e">createBuffer</span>({
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">size</span>: <span style="color:#66d9ef">uniformBufferSize</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">usage</span>: <span style="color:#66d9ef">GPUBufferUsage.UNIFORM</span> <span style="color:#f92672">|</span> <span style="color:#a6e22e">GPUBufferUsage</span>.<span style="color:#a6e22e">COPY_DST</span>
</span></span><span style="display:flex;"><span>  });
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">device</span>.<span style="color:#a6e22e">queue</span>.<span style="color:#a6e22e">writeBuffer</span>(
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">uniformBuffer</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#ae81ff">0</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">Float32Array</span>([<span style="color:#a6e22e">width</span>, <span style="color:#a6e22e">height</span>])
</span></span><span style="display:flex;"><span>  );
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">graphicsBindGroup</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">device</span>.<span style="color:#a6e22e">createBindGroup</span>({
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">layout</span>: <span style="color:#66d9ef">graphicsBindGroupLayout</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">entries</span><span style="color:#f92672">:</span> [
</span></span><span style="display:flex;"><span>      {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">binding</span>: <span style="color:#66d9ef">0</span>,
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">resource</span><span style="color:#f92672">:</span> {
</span></span><span style="display:flex;"><span>          <span style="color:#a6e22e">buffer</span>: <span style="color:#66d9ef">uniformBuffer</span>,
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>      },
</span></span><span style="display:flex;"><span>      {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">binding</span>: <span style="color:#66d9ef">1</span>,
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">resource</span><span style="color:#f92672">:</span> {
</span></span><span style="display:flex;"><span>          <span style="color:#a6e22e">buffer</span>: <span style="color:#66d9ef">colorBuffer</span>,
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>    ]
</span></span><span style="display:flex;"><span>  });
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">renderPassDescriptor</span>: <span style="color:#66d9ef">GPURenderPassDescriptor</span> <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">colorAttachments</span><span style="color:#f92672">:</span> [
</span></span><span style="display:flex;"><span>      {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">view</span>: <span style="color:#66d9ef">currentTexture.createView</span>(),
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">clearValue</span><span style="color:#f92672">:</span> [<span style="color:#ae81ff">1.0</span>, <span style="color:#ae81ff">0.0</span>, <span style="color:#ae81ff">0.0</span>, <span style="color:#ae81ff">1.0</span>],
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">loadOp</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;clear&#34;</span>,
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">storeOp</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;store&#34;</span>
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>    ]
</span></span><span style="display:flex;"><span>  };
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">renderCommandEncoder</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">device</span>.<span style="color:#a6e22e">createCommandEncoder</span>();
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">renderPass</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">renderCommandEncoder</span>.<span style="color:#a6e22e">beginRenderPass</span>(<span style="color:#a6e22e">renderPassDescriptor</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">renderPass</span>.<span style="color:#a6e22e">setPipeline</span>(<span style="color:#a6e22e">graphicsPipeline</span>);
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">renderPass</span>.<span style="color:#a6e22e">setBindGroup</span>(<span style="color:#ae81ff">0</span>, <span style="color:#a6e22e">graphicsBindGroup</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// draw 6 vertices
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// we are not providing any vertex data,
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// which are hard coded in the vertex shader.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#a6e22e">renderPass</span>.<span style="color:#a6e22e">draw</span>(<span style="color:#ae81ff">6</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">renderPass</span>.<span style="color:#a6e22e">end</span>();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">device</span>.<span style="color:#a6e22e">queue</span>.<span style="color:#a6e22e">submit</span>([<span style="color:#a6e22e">renderCommandEncoder</span>.<span style="color:#a6e22e">finish</span>()]);
</span></span></code></pre></div><p>The graphics pipeline setup is more involved than the compute pipeline, because it has more moving parts, but the idea is the same. We create a pipeline, bind the resources to the pipeline, and submit the command to the queue.</p>
<p>If all goes well, you will get a screen with a faded gradient color on your screen.</p>
<h2 id="draw-a-triangle">Draw a triangle<a hidden class="anchor" aria-hidden="true" href="#draw-a-triangle">#</a></h2>
<p>Now that we have the basic routine setup, let&rsquo;s feed a triangle to the compute shader and rasterize it on the screen.</p>
<p>First, we need to create a vertex buffer. The vertex buffer contains the vertex data we want to draw. In this case, we want to draw a triangle, so we need to create a vertex buffer with 3 vertices.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span>  <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">vertices</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">Float32Array</span>([
</span></span><span style="display:flex;"><span>      <span style="color:#ae81ff">10</span>, <span style="color:#ae81ff">10</span>,
</span></span><span style="display:flex;"><span>      <span style="color:#ae81ff">10</span>, <span style="color:#ae81ff">80</span>,
</span></span><span style="display:flex;"><span>      <span style="color:#ae81ff">80</span>, <span style="color:#ae81ff">10</span>
</span></span><span style="display:flex;"><span>  ]);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">vertexBuffer</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">device</span>.<span style="color:#a6e22e">createBuffer</span>({
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">size</span>: <span style="color:#66d9ef">vertices.byteLength</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">usage</span>: <span style="color:#66d9ef">GPUBufferUsage.STORAGE</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">mappedAtCreation</span>: <span style="color:#66d9ef">true</span>
</span></span><span style="display:flex;"><span>  });
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">Float32Array</span>(<span style="color:#a6e22e">vertexBuffer</span>.<span style="color:#a6e22e">getMappedRange</span>()).<span style="color:#66d9ef">set</span>(<span style="color:#a6e22e">vertices</span>);
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">vertexBuffer</span>.<span style="color:#a6e22e">unmap</span>();
</span></span></code></pre></div><p>we also need to pass screen width and height to the compute shader, so we need to update the uniform buffer, and the bind group layout and bind group object.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span>  <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">uniformBufferSize</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">4</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">2</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">uniformBuffer</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">device</span>.<span style="color:#a6e22e">createBuffer</span>({
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">size</span>: <span style="color:#66d9ef">uniformBufferSize</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">usage</span>: <span style="color:#66d9ef">GPUBufferUsage.UNIFORM</span> <span style="color:#f92672">|</span> <span style="color:#a6e22e">GPUBufferUsage</span>.<span style="color:#a6e22e">COPY_DST</span>
</span></span><span style="display:flex;"><span>  });
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">device</span>.<span style="color:#a6e22e">queue</span>.<span style="color:#a6e22e">writeBuffer</span>(
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">uniformBuffer</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#ae81ff">0</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">Float32Array</span>([<span style="color:#a6e22e">width</span>, <span style="color:#a6e22e">height</span>])
</span></span><span style="display:flex;"><span>  );
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">bindGroupLayout</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">device</span>.<span style="color:#a6e22e">createBindGroupLayout</span>({
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">entries</span><span style="color:#f92672">:</span> [
</span></span><span style="display:flex;"><span>      {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">binding</span>: <span style="color:#66d9ef">0</span>,
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">visibility</span>: <span style="color:#66d9ef">GPUShaderStage.COMPUTE</span>,
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">buffer</span><span style="color:#f92672">:</span> {
</span></span><span style="display:flex;"><span>          <span style="color:#66d9ef">type</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;storage&#34;</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>      },
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>      <span style="color:#75715e">/// NEW!!!
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>      {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">binding</span>: <span style="color:#66d9ef">1</span>,
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">visibility</span>: <span style="color:#66d9ef">GPUShaderStage.COMPUTE</span>,
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">buffer</span><span style="color:#f92672">:</span> {
</span></span><span style="display:flex;"><span>          <span style="color:#66d9ef">type</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;read-only-storage&#34;</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>      },
</span></span><span style="display:flex;"><span>      {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">binding</span>: <span style="color:#66d9ef">2</span>,
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">visibility</span>: <span style="color:#66d9ef">GPUShaderStage.COMPUTE</span>,
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">buffer</span><span style="color:#f92672">:</span> {
</span></span><span style="display:flex;"><span>          <span style="color:#66d9ef">type</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;uniform&#34;</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>    ]
</span></span><span style="display:flex;"><span>  });
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// create bind group
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">bindGroup</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">device</span>.<span style="color:#a6e22e">createBindGroup</span>({
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">layout</span>: <span style="color:#66d9ef">bindGroupLayout</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">entries</span><span style="color:#f92672">:</span> [
</span></span><span style="display:flex;"><span>      {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">binding</span>: <span style="color:#66d9ef">0</span>,
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">resource</span><span style="color:#f92672">:</span> {
</span></span><span style="display:flex;"><span>          <span style="color:#a6e22e">buffer</span>: <span style="color:#66d9ef">colorBuffer</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>      },
</span></span><span style="display:flex;"><span>      {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">binding</span>: <span style="color:#66d9ef">1</span>,
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">resource</span><span style="color:#f92672">:</span> {
</span></span><span style="display:flex;"><span>          <span style="color:#a6e22e">buffer</span>: <span style="color:#66d9ef">vertexBuffer</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>      },
</span></span><span style="display:flex;"><span>      {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">binding</span>: <span style="color:#66d9ef">2</span>,
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">resource</span><span style="color:#f92672">:</span> {
</span></span><span style="display:flex;"><span>          <span style="color:#a6e22e">buffer</span>: <span style="color:#66d9ef">uniformBuffer</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>    ]
</span></span><span style="display:flex;"><span>  });
</span></span></code></pre></div><p>Now we need to update the compute shader to read the vertex data from the vertex buffer.</p>
<pre tabindex="0"><code class="language-wgsl" data-lang="wgsl">// create a draw line and draw pixel function

fn draw_pixel(x: u32, y: u32, r: u32, g: u32, b: u32) {
  let index = u32(x + y * u32(uniforms.screenWidth)) * 3;
  color_buffer.values[index] = r;
  color_buffer.values[index + 1] = g;
  color_buffer.values[index + 2] = b;
}


// bresenham&#39;s line algorithm
fn draw_line(v1: vec2&lt;f32&gt;, v2: vec2&lt;f32&gt;) {
  let dx = v2.x - v1.x;
  let dy = v2.y - v1.y;

  let steps = max(abs(dx), abs(dy));

  let x_increment = dx / steps;
  let y_increment = dy / steps;

  for(var i = 0u; i &lt; u32(steps); i = i + 1) {
    let x = u32(v1.x + f32(i) * x_increment);
    let y = u32(v1.y + f32(i) * y_increment);
    draw_pixel(x, y, 255, 255, 255);
  }
}
</code></pre><p>you can find more information about bresenham&rsquo;s line algorithm <a href="https://en.wikipedia.org/wiki/Bresenham%27s_line_algorithm">here</a>.</p>
<p>You should see a triangle in wireframe mode on the screen. My implementation can be found <a href="https://github.com/eddychu/webgpu-rasterizer.git">here</a></p>
<p>We can extend this basic example to fill the triangle with color and add vertex transformation and camera feature, even with pbr material and  lighting calculation. But that is for another day.</p>
<p><strong>Reference</strong></p>
<p><a href="https://github.com/OmarShehata/webgpu-compute-rasterizer/blob/main/how-to-build-a-compute-rasterizer.md">How to Build a Compute Rasterizer with WebGPU</a></p>
<p><a href="https://surma.dev/things/webgpu/">WebGPU — All of the cores, none of the canvas</a></p>
<p><a href="https://austin-eng.com/webgpu-samples/">WebGPU Samples</a></p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2023 <a href="http://example.org/">My New Hugo Site</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
